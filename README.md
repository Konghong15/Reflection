## 🪞 리플렉션(Reflection)이란?

리플렉션은 **프로그램이 실행 중에 자신의 구조나 타입 정보를 조회하고 조작할 수 있도록 하는 기술**입니다.  
클래스, 변수, 함수 등의 메타데이터를 생성하고, 이를 기반으로 객체를 생성하거나, 속성 값을 읽고 쓰거나, 메서드를 호출할 수 있습니다.

---

## ❓ 왜 리플렉션이 필요한가?

리플렉션은 **모듈 간 결합도를 낮추고, 유연한 구조를 만들기 위해** 사용됩니다.

게임 엔진에서는 **엔진 모듈이 게임 모듈의 구조를 알지 못한 채** 해당 기능을 사용해야 하는 경우가 많습니다.  
이러한 상황에서 리플렉션은 런타임에 메타데이터를 통해 구조를 조회하고 제어할 수 있도록 도와줍니다.

범용적으로 설계된 하위 모듈은 상위 모듈의 세부 정보를 알 수 없기 때문에,  
**객체 구조를 메타데이터로 전달받아 처리**하는 방식이 일반적입니다.

그래픽스 라이브러리의 경우, 렌더링을 위해 버퍼를 전달할 때  
해당 버퍼의 **레이아웃 정보 역시 함께 제공**되며, 이를 기반으로 처리하게 됩니다.

---

## 🗑️ 가비지 컬렉터(Garbage Collector)란?

가비지 컬렉터는 **더 이상 사용되지 않는 객체를 자동으로 감지하고 메모리에서 해제해주는 시스템**입니다.  
프로그래머가 객체를 직접 소멸시키지 않아도 되어, 메모리 누수나 이중 해제와 같은 오류를 방지할 수 있습니다.

---

## ❓ 왜 가비지 컬렉터가 필요한가?

동적으로 생성된 객체는 명확한 생명 주기 관리가 어렵고, 협업 환경에서는 더욱 복잡한 문제가 발생할 수 있습니다.  
이러한 상황에서 가비지 컬렉터는 다음과 같은 장점을 제공합니다:

- **자동 메모리 관리**로 인한 개발 편의성 향상  
- **객체 수명 주기의 명확한 분리**로 협업 시 안정성 강화  
- **메모리 누수 및 잘못된 해제 방지**

# 🧪 테스트 스크린샷

아래는 주요 기능을 테스트한 결과입니다.

---

### 🧬 상속 구조 테스트

런타임 타입 정보를 통해 상속 계층을 확인하는 테스트입니다.

![상속 구조](./images/TestTypeInfo.png)

---

### 🏷️ 프로퍼티 시스템 테스트

객체의 멤버 변수에 대한 메타데이터를 정의하고 조회하는 예제입니다.

![프로퍼티1](./images/TestProperty1.png)  
![프로퍼티2](./images/TestProperty2.png)

---

### 🧩 메서드 등록 및 호출 테스트

리플렉션 시스템을 통해 메서드를 등록하고, 런타임에 호출하는 예제입니다.

![메서드1](./images/TestMethod1.png)  
![메서드2](./images/TestMethod2.png)

---

### 🔁 가비지 컬렉션 테스트

GC 시스템이 동작하며 객체를 추적하고 해제하는 테스트입니다.

![GC1](./images/TestGC1.png)  
![GC2](./images/TestGC2.png)  
![GC3](./images/TestGC3.png)

---

### 🌐 RPC 테스트

네트워크를 통한 원격 함수 호출을 리플렉션 기반으로 처리하는 예제입니다.

![RPC1](./images/TestRPC1.png)  
![RPC2](./images/TestRPC2.png)
