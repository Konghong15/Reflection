# C++ 리플렉션 / GC 시스템

---

## 1. 개념 설명

### 리플렉션(Reflection)이란?

리플렉션은 **프로그램이 실행 중에 자신의 구조나 타입 정보를 조회하고 조작할 수 있도록 하는 기술**입니다.  
클래스, 변수, 함수 등의 **메타데이터를 생성**하고, 이를 기반으로 객체를 생성하거나, 속성 값을 읽고 쓰거나, 메서드를 호출할 수 있습니다.

### 리플렉션이 필요한 이유

리플렉션은 **모듈 간 결합도를 낮추고 유연한 구조를 만들기 위해** 사용됩니다.

게임 엔진에서는 **엔진 모듈이 게임 모듈의 구조를 알지 못한 채** 해당 기능을 사용해야 하는 경우가 많습니다.  
이러한 상황에서 리플렉션은 **런타임에 메타데이터를 통해 구조를 조회하고 제어**할 수 있도록 도와줍니다.

이처럼 **범용적으로 설계된 하위 모듈이 상위 모듈의 세부 정보를 알 수 없는 경우**,  
**객체 구조에 대한 메타데이터를 전달받아 이를 기반으로 처리하는 방식**은 일반적입니다.

### 가비지 컬렉터(Garbage Collector)란?

가비지 컬렉터는 **더 이상 사용되지 않는 객체를 자동으로 감지하고 메모리에서 해제**해주는 시스템입니다.  
프로그래머가 객체를 직접 소멸시키지 않아도 되어, **메모리 누수나 이중 해제와 같은 오류를 방지**할 수 있습니다.

### 가비지 컬렉터가 필요한 이유

동적으로 생성된 객체는 **명확한 생명 주기 관리가 어렵고**, 협업 환경에서는 더욱 복잡한 문제가 발생할 수 있습니다.  
이러한 상황에서 가비지 컬렉터는 다음과 같은 장점을 제공합니다:

- **자동 메모리 관리**로 인한 개발 편의성 향상  
- **객체 수명 주기의 명확한 분리**로 협업 시 안정성 강화  
- **메모리 누수 및 잘못된 해제 방지**

---

## 2. 기능 테스트 스크린샷

아래는 리플렉션 및 가비지 컬렉션 시스템의 주요 테스트 결과입니다.

### 상속 구조 테스트

<img src="./images/TestTypeInfo.png" width="600">

- `Cat` 인스턴스를 `Animal*`로 참조한 후,  
  리플렉션을 통해 **실제 타입(`Cat`)과 상속 관계를 판별**할 수 있는지 확인합니다.

### 프로퍼티 시스템 테스트

<img src="./images/TestProperty1.png" width="600">  
<img src="./images/TestProperty2.png" width="600">

- 필드의 이름과 타입을 조회할 수 있으며,  
  **이름 기반으로 `Get`/`Set`을 호출**할 수 있습니다.

### 메서드 등록 및 호출 테스트

<img src="./images/TestMethod1.png" width="600">  
<img src="./images/TestMethod2.png" width="600">

- 함수의 이름, 반환형, 매개변수 타입을 조회할 수 있고,  
  **런타임에 이름과 인자를 전달해 함수 호출**이 가능합니다.

### 가비지 컬렉션 테스트

<img src="./images/TestGC1.png" width="600">  
<img src="./images/TestGC2.png" width="600">  
<img src="./images/TestGC3.png" width="600">

- **Mark and Sweep** 방식의 GC로, 루트 객체를 기준으로 참조 그래프를 순회하며 사용 중인 객체만 추적합니다.
- 수거 대상 객체를 **정확히 식별 및 해제**할 수 있음을 확인합니다.
- 현재는 **멀티스레드 환경에서 성능 저하** 이슈가 존재합니다.

### RPC 테스트

<img src="./images/TestRPC1.png" width="600">  
<img src="./images/TestRPC2.png" width="600">

- 함수 이름과 매개변수 타입을 기반으로,  
  **문자열 형태의 호출 정보로 런타임 함수 실행**이 가능합니다.
- 현재는 **네트워크 연동 미지원** 상태입니다.

---

## 3. 참고 자료

- [A Primitive Reflection System in C++ (Part 1) – Preshing](https://preshing.com/20180116/a-primitive-reflection-system-in-cpp-part-1/)  
- [A Flexible Reflection System in C++ (Part 2) – Preshing](https://preshing.com/20180124/a-flexible-reflection-system-in-cpp-part-2/)  
- [[2019] 언리얼 엔진을 통해 살펴보는 리플렉션과 가비지 컬렉션](https://www.youtube.com/watch?v=VpEe9DbcZIs)  
- [슬라이드쉐어: C++20 메타프로그래밍과 리플렉션 개념 정리](https://www.slideshare.net/slideshow/c20-251161090/251161090)
